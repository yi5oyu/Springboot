<div align="center">

# **Java 예외**   

</div>

`예외 계층구조`

<img width="1200" height="680" alt="image" src="https://github.com/user-attachments/assets/3e368543-9028-4ad6-9a57-cf5eb07eca5d" />

## [Throwable](https://github.com/yi5oyu/Study/blob/main/SpringBoot/0%20Error/Throwable.md) 

`java.lang.Throwable`

```
Java의 모든 예외와 에러의 최상위 클래스
Throwable을 상속해야만 throw 가능

public class AException extends Throwable { }

try {
    throw new AException();
} catch (Throwable t) {
    // catch 가능
}
```

 - 상태 저장: 에러 메시지(detailMessage)와 원인(cause) 저장
 - 스택 트레이스: 예외 발생 시점의 메서드 호출 스택 정보를 캡처(fillInStackTrace).
 - 직렬화: 예외 정보를 네트워크나 파일로 전달할 수 있도록 Serializable 구현

### [Error](https://github.com/yi5oyu/Study/blob/main/SpringBoot/0%20Error/Error.md)

`시스템 레벨의 심각한 오류`

```
// https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Error.html

An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.
Most such errors are abnormal conditions.
The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.

Error는 합리적인 애플리케이션이라면 catch하려고 시도해서는 안 되는 심각한 문제들을 나타냄
대부분 비정상적인 상황이며 ThreadDeath처럼 정상적인 상황도 있지만 여전히 catch 하면 안 됨
```

`JVM 자체의 문제`

OutOfMemoryError: 힙 메모리 부족   
StackOverflowError: 스택 메모리 부족(무한 재귀 등)    
VirtualMachineError: JVM 내부 오류   
...

`복구 불가능`

```
// 어차피 개발자가 해결할 수 있는 문제가 아니기 때문에 컴파일러가 확인할 필요없음
 
try {
    List list = new ArrayList<>();
    while(true) {
        // 메모리 계속 할당
        list.add(new byte[1024 * 1024]);
    }
} catch (OutOfMemoryError e) {
    // 이미 메모리가 없어 개발자가 try-catch 코드작성으로 해결 할 수 있는게 없음
}
```

### [Exception](https://github.com/yi5oyu/Study/blob/main/SpringBoot/0%20Error/Exception.md)

`애플리케이션에서의 문제`

프로그램 실행 중 발생할 수 있는 예상 가능한 문제로 개발자가 예외 처리(catch)로 프로그램을 계속 실행할 수 있음

#### Checked Exception

`컴파일러(javac)가 처리를 강제하는 예외`

개발자의 실수와 무관하게 언제든 실패할 수 있는 로직에 사용

`외부 요인에 의한 문제`

FileNotFoundException: 파일 시스템   
IOException: 네트워크   
SQLException: 데이터베이스   
...

- 예외 처리/사용 방법

```java
// 처리 방법 

// try-catch
//  - 직접 처리: 예외가 발생하면 catch 블록으로 감(프로그램 이어서 실행됨)
public void a() {
    try {
        // 외부 API 호출
        throw new ExternalApiFailedException("API 응답 오류");
    } catch (IOException e | InterruptedException e) {
        // 네트워크가 끊겼거나, 요청 중 스레드가 종료됨
        Thread.currentThread().interrupt(); // Interrupted 상태 복구
        throw new ExternalApiFailedException("외부 서버 통신 실패", e);
    }
}

// throws
//  - 책임 전가: 호출한 쪽에서 처리(호출한 곳으로 예외 객체를 던짐. main 메서드까지 간다면 JVM이 받아 프로그램 종료 될 수 있음)
public void a() throws IOException, InterruptedException {    
    // 외부 API 호출
    // 여기서 에러가 나면 즉시 실행을 멈추고 나를 호출한 쪽으로 예외가 감
}

// 사용 방법

// 재시도
public String a(String url) {
    int maxRetries = 3; 
    
    for (int i = 0; i < maxRetries; i++) {
        try {
            // 성공 시 결과 반환하고 종료
            return api.call(url); 

        } catch (IOException e) {
            // 실패 시 재시도
            try { Thread.sleep(1000); } catch (InterruptedException ie) {}
            // 마지막 시도까지 실패하면 예외
            if (i == maxRetries - 1) throw new RuntimeException("API 호출 실패");
        }
    }
    return null;
}

// 예외 전환
public void a(User user) {
    try {
        // SQL 예외 발생 가능(Checked Exception)
        repository.save(user); 

    } catch (SQLException e) {
        // 새로운 예외로 만들어 던짐(Unchecked Exception)
        throw new UserRegistrationException("회원 가입 시스템 오류", e);
    }
}
```

#### Unchecked Exception(RuntimeException)

`개발자의 실수/로직 오류로 발생하는 예외`

```
컴파일러에서는 통과
트랜잭션에선 예외 발생 시 자동으로 롤백됨
```

`프로그래밍 오류`

Null 체크 누락    
배열 인덱스 초과    
타입 캐스팅 오류    
유효성 검증 누락    
...

- 예외 처리

```java
// 코드를 수정하거나 예외 발생 시점 예측해 미리 검증
public void process(String str) {
    if (str == null) {
        // NullPointerException 대신 예외 발생시킴(호출한 쪽에서 null을 발생해서 발생한 문제임을 명확하게 함)
        throw new IllegalArgumentException("문자열은 null일 수 없음");
    }
    int length = str.length();
}
```

## 커스텀 예외

`Unchecked Exception(RuntimeException) 기반`

```java
// RuntimeException 상속 받음(Checked는 Exception 상속)
public class UserNotFoundException extends RuntimeException {
    // 메시지(message) 생성자와 원인(cause) 생성자는 필수

    // 메시지만 넘기는 생성자
    public UserNotFoundException(String message) {
        super(message);
    }

    // 메시지와 원인 예외를 같이 넘기는 생성자
    public UserNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

// 사용
public User findUser(Long id) {
    return userRepository.findById(id)
        .orElseThrow(() -> new UserNotFoundException("존재하지 않는 회원 ID: " + id));
}
```
