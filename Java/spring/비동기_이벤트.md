<div align="center">

# 비동기 이벤트 처리

`응답 속도 + 결합도 개선`    

</div>

`하나의 서비스에서 여러 기능을 순차 처리해 응답 속도 느려짐`

```java
@Service
@RequiredArgsConstructor
public class UserService {
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    private final CouponService couponService;
    
    @Transactional
    public UserResponse registerUser(UserRegisterRequest request) {
        // 회원 저장
        User user = User.create(request);
        User savedUser = userRepository.save(user); 
        
        // 이메일 발송
        try {
            emailService.sendWelcomeEmail(
                savedUser.getEmail(), 
                savedUser.getName()
            ); 
        } catch (Exception e) {
            log.error("이메일 발송 실패", e);
        }
        
        // 신규 가입 쿠폰 발급
        try {
            couponService.issueWelcomeCoupon(savedUser.getId());
        } catch (Exception e) {
            log.error("쿠폰 발급 실패", e);
        }
        
        return UserResponse.from(savedUser);
    }
}
```

`비동기 + 이벤트 적용`

```java
// 이벤트 정의
@Getter
@AllArgsConstructor
public class UserRegisteredEvent {
    private final Long userId;
    private final String email;
    private final String name;
}

@Service
@RequiredArgsConstructor
public class UserService {
    
    private final UserRepository userRepository;
    private final ApplicationEventPublisher eventPublisher;
    
    @Transactional
    public UserResponse registerUser(UserRegisterRequest request) {
        // 회원 저장(
        User user = User.create(request);
        User savedUser = userRepository.save(user);
        
        // 이벤트(나머지 기능은 다른곳에서 동작) 
        eventPublisher.publishEvent(new UserRegisteredEvent(
            savedUser.getId(),
            savedUser.getEmail(),
            savedUser.getName()
        )); 
        
        return UserResponse.from(savedUser);
    }
}

// 이벤트 리스너
@Component
@RequiredArgsConstructor
public class UserEventListener {
    
    private final EmailService emailService;
    private final CouponService couponService;
    
    // 이메일 발송(비동기)
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void sendWelcomeEmail(UserRegisteredEvent event) {
        try {
            emailService.sendWelcomeEmail(event.getEmail(), event.getName());
            log.info("이메일 발송 완료");
        } catch (Exception e) {
            log.error("이메일 발송 실패", e);
        }
    }
    
    // 쿠폰 발급(비동기)
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void issueWelcomeCoupon(UserRegisteredEvent event) {
        try {
            couponService.issueWelcomeCoupon(event.getUserId());
            log.info("쿠폰 발급 완료");
        } catch (Exception e) {
            log.error("쿠폰 발급 실패", e);
        }
    }
}
```

## 비동기(@Async)

`사용자 응답에 꼭 필요하지 않은 작업은 다른 스레드에서 나중에 처리`

### 스레드 풀

`기본 Executor 사용`

```java
// 요청에 따라 새 스레드를 생성(메모리 할당)하고 사용 후 GC수거
@Async
public void sendEmail1() {
    Thread thread = new Thread(); 
    thread.start();
}
```

`스레드 풀 정의(ThreadPoolTaskExecutor)`

```java
// 미리 스레드 풀을 정의해 스레드 생성시간 없고 사용 후 재사용

// 공용 스레드 풀
@Configuration
@EnableAsync
public class AsyncConfig {
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);      
        executor.setMaxPoolSize(10);      
        executor.setQueueCapacity(100);   
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}

// 분리 스레드 풀
// 서비스에 따라 스레드 수를 정의해서 최적화 시킬 수 있음
@Configuration
@EnableAsync
public class AsyncConfig {
    @Bean(name = "emailExecutor")
    public Executor emailExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);     
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("email-");
        return executor;
    }
    
    @Bean(name = "aiExecutor")
    public Executor aiExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3); 
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(20);
        executor.setThreadNamePrefix("ai-");
        return executor;
    }
}
```

## 이벤트(@EventListener)

`발행-구독 패턴으로 코드 결합도 낮춤`

```java
// 각 기능이 독립적이므로 새 기능 추가시 Service 변경 필요 없이 리스너만 추가

// 발행: 누가 어떻게 처리하는지 몰르고 발행만 해도 됨
eventPublisher.publishEvent(new OrderCreatedEvent(...));

// 구독: 발행된 이벤트 처리
@EventListener
public void sendEmail(OrderCreatedEvent event) { }

@EventListener
public void updateInventory(OrderCreatedEvent event) { }
```

### TransactionalEventListener

`트랜잭션 커밋 후 리스너 실행`

```java
@Component
public class OrderEventListener {
    // 트랜잭션 커밋 성공 후 실행(롤백될 경우 실행 안됨)
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void sendEmail(OrderCreatedEvent event) {
        emailService.sendOrderConfirmation(event.getOrderId());
    }
}
